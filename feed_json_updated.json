{"version": "https://jsonfeed.org/version/1", "title": "The Agents Nanny", "home_page_url": "https://gradion-ai.github.io/agents-nanny/", "feed_url": "https://gradion-ai.github.io/agents-nanny/feed_json_updated.json", "description": "A blog with random topics about ML and AI.", "icon": null, "authors": [{"name": "Martin Krasser"}], "language": "en", "items": [{"id": "https://gradion-ai.github.io/agents-nanny/2025/12/16/code-actions-as-tools-evolving-tool-libraries-for-agents/", "url": "https://gradion-ai.github.io/agents-nanny/2025/12/16/code-actions-as-tools-evolving-tool-libraries-for-agents/", "title": "Code Actions as Tools: Evolving Tool Libraries for Agents", "content_html": "<h1>Code Actions as Tools: Evolving Tool Libraries for Agents</h1>\n<p>Programmatic tool calling is gaining traction in agent development. Instead of emitting one JSON tool call at a time, agents generate executable \"code actions\" that call tools in a sandboxed environment. This pattern is inspired by Apple's <a href=\"https://machinelearning.apple.com/research/codeact\">CodeAct</a> and appears in many agentic systems. More <a href=\"https://platform.claude.com/docs/en/agents-and-tools/tool-use/programmatic-tool-calling\">recent</a> <a href=\"https://blog.cloudflare.com/code-mode/\">implementations</a> increasingly focus on programmatic calling of MCP tools.</p>\n<p>These solutions typically generate Python or TypeScript APIs for MCP tools, let an agent write code actions that call these APIs, execute the code in a sandboxed environment, and feed results back to the agent. This improves performance compared to JSON-based approaches, but it often misses an important point: a generated code action can itself become a tool, available for reuse in later code actions.</p>", "image": null, "date_modified": "2025-12-16T11:25:33+00:00", "authors": [{"name": "Martin Krasser"}], "tags": ["Code actions", "Programmatic tool calling"]}, {"id": "https://gradion-ai.github.io/agents-nanny/2025/11/12/from-single-user-to-multi-party-conversational-ai/", "url": "https://gradion-ai.github.io/agents-nanny/2025/11/12/from-single-user-to-multi-party-conversational-ai/", "title": "From Single-User to Multi-Party Conversational AI", "content_html": "<h1>From Single-User to Multi-Party Conversational AI</h1>\n<p>Single-user AI agents excel at responding to direct queries in one-on-one interactions. A user sends the agent a self-contained query with sufficient context, and the agent processes it directly. Even in group chats, the typical pattern remains the same: users mention the agent with a direct query. This interaction model treats multi-user environments as collections of individual exchanges rather than true multi-party conversations.</p>\n<p>Multi-party conversational AI systems, on the other hand, must derive agent queries from more complex exchanges between multiple participants. This requires detecting meaningful patterns while knowing when to stay silent. For example, when a conversation stalls on a decision, the system detects that and suggests resolutions based on available agent capabilities. Single-user agents respond to every input, but multi-party AI must engage only when specific patterns emerge.</p>", "image": null, "date_modified": "2025-11-12T10:28:27+00:00", "authors": [{"name": "Martin Krasser"}], "tags": ["Group assistance"]}, {"id": "https://gradion-ai.github.io/agents-nanny/2025/08/06/agent-authorization-without-the-pain/", "url": "https://gradion-ai.github.io/agents-nanny/2025/08/06/agent-authorization-without-the-pain/", "title": "Agent Authorization Without the Pain", "content_html": "<h1>Agent Authorization Without the Pain</h1>\n<p>Your agent needs to read from your Google Calendar and send emails through Gmail. This seemingly simple requirement quickly becomes complex when you realize you need OAuth flows, token refresh logic, and secure credential storage. Multiply that by every API your agent needs.</p>\n<p>You shouldn't have to build this infrastructure yourself. Connect your agents to 250+ APIs and 3000+ tools with <a href=\"https://modelcontextprotocol.io/\">Model Context Protocol</a> (MCP) and <a href=\"https://composio.dev/\">Composio</a>. Composio handles authorization, remote MCP servers and tool execution, while your application focuses on agentic reasoning and tool usage.</p>", "image": null, "date_modified": "2025-09-12T06:17:13+00:00", "authors": [{"name": "Martin Krasser"}], "tags": ["Agent authorization"]}]}