{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"2025/08/06/agent-authorization-without-the-pain/","title":"Agent Authorization Without the Pain","text":"<p>Your agent needs to read from your Google Calendar and send emails through Gmail. This seemingly simple requirement quickly becomes complex when you realize you need OAuth flows, token refresh logic, and secure credential storage. Multiply that by every API your agent needs.</p> <p>You shouldn't have to build this infrastructure yourself. Connect your agents to 250+ APIs and 3000+ tools with Model Context Protocol (MCP) and Composio. Composio handles authorization, remote MCP servers and tool execution, while your application focuses on agentic reasoning and tool usage.</p> <p>Note</p> <p>I'm not affiliated with Composio, I'm just a happy user. Their approach supports a useful separation of concerns between agent logic and API integration in agentic applications.</p>"},{"location":"2025/08/06/agent-authorization-without-the-pain/#architecture","title":"Architecture","text":"<p>Your Application</p> <ul> <li>Agents connect to Composio MCP servers and use their tools</li> <li>Agents act on behalf of users that authorized API access</li> <li>Agents focus on reasoning and tool usage, not plumbing</li> </ul> <p>Composio Layer</p> <ul> <li>MCP servers act as protocol bridges to external APIs</li> <li>Each API has an auth config, with a connected account per user</li> <li>Auth tokens are stored securely, supporting OAuth2, API keys, etc.</li> </ul> <p>Key Benefits</p> <ul> <li>No OAuth flows or token management in your code</li> <li>Access 250+ APIs and 3000+ tools through MCP</li> <li>Clean separation between agent logic and API integration</li> </ul>"},{"location":"2025/08/06/agent-authorization-without-the-pain/#example","title":"Example","text":"Your browser does not support the video tag.  <p>The complete code is at github.com/krasserm/agent-auth. What follows is an overview of the key steps needed to authorize an agent to use Google Calendar on behalf of a user:</p> <p>Install the Composio Python library, used to access the Composio REST API.</p> <pre><code>pip install composio-client\n</code></pre> <p>Create an auth configuration for the googlecalendar toolkit, using <code>OAUTH2</code> as <code>authScheme</code>.</p> <pre><code>client = Composio(api_key=os.getenv(\"COMPOSIO_API_KEY\"))\n\nresponse = client.auth_configs.create(\n    toolkit={\"slug\": \"googlecalendar\"},\n    auth_config={\n        \"name\": \"calendar-example\", \n        \"type\": \"use_composio_managed_auth\",\n        \"authScheme\": \"OAUTH2\"\n    }\n)\nauth_config_id = response.auth_config.id\n</code></pre> <p>Add a connected account to the auth config and link a <code>user_id</code> to it. That's the id of a user managed by your application, not by Composio.</p> <pre><code>response = client.connected_accounts.create(\n    auth_config={\"id\": auth_config_id},\n    connection={\"user_id\": \"martin\"},\n)\n</code></pre> <p>Initiate the authorization process by redirecting to an OAuth consent screen in a browser window. After completion, the connected account is authorized to use Google Calendar on behalf of the user who granted access.</p> <pre><code>import webbrowser\n\nwebbrowser.open(response.connection_data.val.redirect_url)\n</code></pre> <p>Create an MCP server for the auth config created in step 2 and specify the tools that should be exposed.</p> <pre><code>result = client.mcp.create(\n    name=\"calendar-mcp-server\",\n    auth_config_ids=[auth_config_id],\n    allowed_tools=[\"GOOGLECALENDAR_FIND_EVENT\"]\n)\n</code></pre> <p>Create an MCP server URL that uses the connected account linked to <code>martin</code>.</p> <pre><code>mcp_url = result.mcp_url.replace(\"transport=sse\", \"user_id=martin\")\n# i.e. https://mcp.composio.dev/composio/server/&lt;uuid&gt;?user_id=martin\n# &lt;uuid&gt; is a string of pattern 12345678-90ab-cdef-1234-567890abcdef\n</code></pre> <p>Configure a Pydantic AI agent with the <code>mcp_url</code> so that it can use Google Calendar on behalf of the user who granted access in step 4.</p> <pre><code>from pydantic_ai import Agent\nfrom pydantic_ai.mcp import MCPServerStreamableHTTP\n\nagent = Agent(\n    'openai:o4-mini',\n    toolsets=[\n        MCPServerStreamableHTTP(mcp_url),  \n    ]\n)\n\nasync with agent:\n    result = await agent.run(\n        \"List my Sep 2025 calendar events\"\n    )\n\nprint(result.output)\n</code></pre>"},{"location":"2025/11/12/from-single-user-to-multi-party-conversational-ai/","title":"From Single-User to Multi-Party Conversational AI","text":"<p>Single-user AI agents excel at responding to direct queries in one-on-one interactions. A user sends the agent a self-contained query with sufficient context, and the agent processes it directly. Even in group chats, the typical pattern remains the same: users mention the agent with a direct query. This interaction model treats multi-user environments as collections of individual exchanges rather than true multi-party conversations.</p> <p>Multi-party conversational AI systems, on the other hand, must derive agent queries from more complex exchanges between multiple participants. This requires detecting meaningful patterns while knowing when to stay silent. For example, when a conversation stalls on a decision, the system detects that and suggests resolutions based on available agent capabilities. Single-user agents respond to every input, but multi-party AI must engage only when specific patterns emerge.</p>"},{"location":"2025/11/12/from-single-user-to-multi-party-conversational-ai/#architectural-approach","title":"Architectural Approach","text":"<p>Modifying existing single-user agents through fine-tuning or prompting does not scale. The solution lies in enabling single-user agents to participate in multi-party conversations without requiring modification to the agents themselves. This requires a separate integration layer between group chat and downstream agents.</p> <p>This layer detects patterns in group conversations and transforms them into self-contained queries that single-user agents can process. The layer monitors the conversation, identifies when specific engagement criteria are met, and translates the relevant context into actionable agent requests. For example, when a factual contradiction emerges, it initiates a fact check and informs the group of the result.</p> <p>Engagement criteria vary significantly across applications and should evolve based on group feedback. The layer must support flexible definition of custom criteria in natural language, processed by a reasoning model. It must also provide a feedback mechanism to update the criteria. It acts as a specialized adapter (\"group reasoner\") between group chat and downstream AI agents, implementing group engagement logic through pattern detection and query transformation.</p> <p> </p>"},{"location":"2025/11/12/from-single-user-to-multi-party-conversational-ai/#reference-implementations","title":"Reference Implementations","text":"<p>Reference implementations of this architectural pattern are provided by the open-source projects Group Sense, Group Genie, and Hybrid Groups.</p> <p>Group Sense provides the group reasoner component. It detects patterns in group chat messages and transforms them into queries for AI systems. The library supports both shared, single-threaded reasoning and concurrent reasoning across group members. Concurrent reasoners process group context redundantly but scale better to larger, highly active groups.</p> <p>Group Genie combines the group reasoner with an agent integration layer. It enables single-user AI agents to participate in group chat conversations without requiring modification to the agents themselves. It routes generated queries to agents and responses to dynamically determined recipients. Agents can be built on any technology stack and are integrated through a simple interface.</p> <p>Hybrid Groups demonstrates this approach in production environments by integrating Group Genie into Slack and GitHub. A group session corresponds to a thread in Slack or an issue or a pull request in GitHub. The Slack integration supports custom definition of engagement criteria per channel.</p>"},{"location":"2025/11/12/from-single-user-to-multi-party-conversational-ai/#additional-challenges","title":"Additional Challenges","text":"<p>Pattern detection, query transformation, and recipient determination address core requirements for multi-party conversational AI, but additional challenges remain. Agents must be able to act on behalf of individual group members, particularly when following member-specific instructions rather than general group requests.</p> <p>Beyond these implementation concerns, additional research areas are relevant. Further aspects are covered in this selected list of papers:</p> <ul> <li>Overhearing LLM Agents: A Survey, Taxonomy, and Roadmap: AI agents that monitor ambient conversations unobtrusively and provide contextual assistance without interrupting the flow of discussion.</li> <li>Multi-Party Conversational Agents: A Survey: Modeling the mental state of participants, understanding group dialogue content, and predicting conversation flow.</li> <li>Multi-User Chat Assistant (MUCA): Group conversational AI that determines what to say, when to respond, and who to address through three coordinated modules.</li> <li>Multi-User MultiWOZ: Task-Oriented Dialogues among Multiple Users: A method for supporting task-oriented dialogues where multiple users collaboratively make decisions with an agent, including multi-user contextual query rewriting to convert user chats into consumable system queries.</li> </ul>"},{"location":"archive/2025/","title":"November 2025","text":""},{"location":"category/group-assistance/","title":"Group assistance","text":""},{"location":"category/agent-authorization/","title":"Agent authorization","text":""}]}